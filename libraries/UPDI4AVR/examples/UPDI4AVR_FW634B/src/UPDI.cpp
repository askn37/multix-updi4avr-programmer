/**
 * @file UPDI.cpp
 * @author askn (K.Sato) multix.jp
 * @brief
 * @version 0.2
 * @date 2023-11-21
 *
 * @copyright Copyright (c) 2023 askn37 at github.com
 *
 */
#include "Prototypes.h"
#include <avr/pgmspace.h>
#include <api/capsule.h>

/* Normal BREAK length (LOW for 96 characters) */
#if ((UPDI_BAUD_CALC * 100) > 65535)
#define UPDI_BAUD_BREAK 65535
#else
#define UPDI_BAUD_BREAK (UPDI_BAUD_CALC * 100)
#endif

/* BREAK length during HV control (10MHz=712?) */
#define UPDI_BAUD_SHORT_BREAK (F_CPU / 10000)

namespace UPDI {
  static uint8_t nvmprog_key[10] =    /* "NVMProg " */
    {UPDI_SYNCH, UPDI_KEY_64, 0x20, 0x67, 0x6F, 0x72, 0x50, 0x4D, 0x56, 0x4E};
  static uint8_t erase_key[10] =      /* "NVMErase" */
    {UPDI_SYNCH, UPDI_KEY_64, 0x65, 0x73, 0x61, 0x72, 0x45, 0x4D, 0x56, 0x4E};
  static uint8_t urowwrite_key[10] =  /* "NVMUs&te" */
    {UPDI_SYNCH, UPDI_KEY_64, 0x65, 0x74, 0x26, 0x73, 0x55, 0x4D, 0x56, 0x4E};

  static uint8_t _set_ptr_l[] = {
      UPDI_SYNCH
    , UPDI_ST | UPDI_PTR_REG | UPDI_DATA3
    , 0, 0, 0, 0    // 24bit address
  };

  static uint8_t _set_repeat[] = {
      UPDI_SYNCH
    , UPDI_REPEAT | UPDI_DATA1
    , 0             // repeat count (0-255) + 1
    , UPDI_SYNCH
    , UPDI_PTR_INC  // + LD,ST + DATA1,DATA2
  };

  #ifdef ENABLE_DEBUG_UPDI_SENDER
  uint16_t _send_ptr;
  uint8_t _send_buf[512];
  void _send_buf_clear (void) {
    _send_ptr = 0;
  }
  void _send_buf_push (uint8_t data) {
    if (_send_ptr < 512) _send_buf[_send_ptr++] = data;
  }
  size_t _send_buf_copy (void) {
    uint8_t *p = _send_buf;
    uint8_t *q = &JTAG2::packet.body[JTAG2::RSP_DATA];
    size_t i = _send_ptr;
    JTAG2::packet.size_word[0] = 3 + i;
    *q++ = UPDI_CONTROL;
    *q++ = UPDI_NVMCTRL;
    while (i--) *q++ = *p++;
    return _send_ptr;
  }
  #endif
}

void UPDI::setup (void) {
  UPDI_USART.BAUD  = UPDI_BAUD_CALC;
  UPDI_USART.CTRLA = UPDI_USART_CTRLA;
  UPDI_USART.CTRLC = UPDI_USART_CTRLC;
  UPDI_USART.CTRLB = UPDI_USART_ON;
  bit_clear(UPDI_CONTROL, UPDI_CLKU_bp);
}

/* This special system reset will log you out of UPDI */
bool UPDI::Target_Reset (bool _enable) {
  static uint8_t set_ptr_on[] = {
      UPDI_SYNCH
    , UPDI_STCS | UPDI_CS_ASI_RESET_REQ
    , UPDI_RSTREQ
    , UPDI_SYNCH
    , UPDI_STCS | UPDI_CS_CTRLB
    , UPDI_SET_CCDETDIS
  };
  static uint8_t set_ptr_off[] = {
      UPDI_SYNCH
    , UPDI_STCS | UPDI_CS_ASI_RESET_REQ
    , UPDI_NOP
    , UPDI_SYNCH
    , UPDI_STCS | UPDI_CS_CTRLB
    , UPDI_SET_UPDIDIS
  };
  if (!digitalRead(UPDI_TDAT_PIN)) return false;
  BREAK();
  if (_enable) 
    return send_bytes(set_ptr_on, sizeof(set_ptr_on));
  else
    return send_bytes(set_ptr_off, sizeof(set_ptr_off));
}

/* This only does a system reset */
bool UPDI::updi_reset (bool logic) {
  return set_cs_stat(
    UPDI_CS_ASI_RESET_REQ,
    (logic ? UPDI_RSTREQ : UPDI_NOP));
}

/*
 * UPDI reception
 */

void UPDI::drain (void) {
  uint8_t j = 0;
  do {
    if (bit_is_set(UPDI_USART.STATUS, USART_RXCIF_bp)) {
      UPDI_LASTH = UPDI_USART.RXDATAH ^ 0x80;
      UPDI_LASTL = UPDI_USART.RXDATAL;
      j = 0;
    }
  } while (--j);
}

uint8_t UPDI::RECV (void) {
  loop_until_bit_is_set(UPDI_USART.STATUS, USART_RXCIF_bp);
  UPDI_LASTH = UPDI_USART.RXDATAH ^ 0x80;
  #ifdef ENABLE_DEBUG_UPDI_SENDER
  UPDI_LASTL = UPDI_USART.RXDATAL;
  _send_buf_push(UPDI_LASTL);
  return UPDI_LASTL;
  #else
  return UPDI_LASTL = UPDI_USART.RXDATAL;
  #endif
}

/*
 * UPDI transmission : Verify transmitted value with loopback reception
 */

bool UPDI::SEND (uint8_t _data) {
  #ifdef ENABLE_DEBUG_UPDI_SENDER
  _send_buf_push(_data);
  #endif
  bool _r;
  loop_until_bit_is_set(UPDI_USART.STATUS, USART_DREIF_bp);
  UPDI_USART.STATUS = USART_TXCIF_bm;
  UPDI_USART.TXDATAL = _data;
  loop_until_bit_is_set(UPDI_USART.STATUS, USART_TXCIF_bp);
  _r = _data == RECV();
  if (!_r) bit_set(UPDI_LASTH, 0x20);
  return _r;
}

/* BREAK character : Generated by slowing down the sending speed */
void UPDI::BREAK (void) {
  loop_until_bit_is_set(UPDI_USART.STATUS, USART_DREIF_bp);
  UPDI_USART.BAUD = UPDI_BAUD_BREAK;
  /* Maintains low level signal at least 768bit long */
  SEND(UPDI_NOP);
  UPDI_USART.BAUD = UPDI_BAUD_CALC;
  bit_clear(UPDI_CONTROL, UPDI_CLKU_bp);
}

/* Required if repeat transmission fails */
void UPDI::STOP (void) {
  loop_until_bit_is_set(UPDI_USART.STATUS, USART_DREIF_bp);
  UPDI_USART.BAUD <<= 1;
  /* Maintains 12bit length low level signal */
  SEND(0xE0);
  UPDI_USART.BAUD >>= 1;
}

/*
 * Send byte chunks
 */

/* __attribute__((optimize("O0"))) */
bool UPDI::send_bytes (uint8_t *data, uint8_t len) {
  do {
    if (!SEND(*data++)) return false;
  } while (--len);
  return true;
}

/*
 * Repeat header transmission
 */

/* __attribute__((optimize("O0"))) */
bool UPDI::send_repeat_header (uint32_t addr, uint8_t cmd, uint8_t len) {
  _CAPS32(_set_ptr_l[2])->dword = addr;
  _set_repeat[2] = len - 1;
  _set_repeat[4] = UPDI_PTR_INC | cmd;  // ST,LD + DATA1,DATA2
  if (!send_bytes(_set_ptr_l, sizeof(_set_ptr_l) - 1)) return false;
  if (UPDI_ACK != RECV()) return false;
  return send_bytes(_set_repeat, sizeof(_set_repeat));
}

/*
 * Single byte transmission
 */

bool UPDI::st8 (uint32_t addr, uint8_t data) {
  static uint8_t set_ptr[] = {
      UPDI_SYNCH
    , UPDI_STS | UPDI_ADDR3 | UPDI_DATA1
    , 0, 0, 0, 0    // 24bit address
  };
  _CAPS32(set_ptr[2])->dword = addr;
  if (!send_bytes(set_ptr, sizeof(set_ptr) - 1)) return false;
  if (UPDI_ACK != RECV()) return false;
  if (!SEND(data)) return false;
  return UPDI_ACK == RECV();
}

/*
 * Transmission
 */

bool UPDI::sts8 (uint32_t addr, uint8_t *data, uint8_t len) {
  if (send_repeat_header(addr, UPDI_ST|UPDI_DATA1, len)) {
    do {
      if (!SEND(*data++)) break;
      if (UPDI_ACK != RECV()) break;
    } while (--len);
  }
  return len == 0;
}

bool UPDI::sts16 (uint32_t addr, uint8_t *data, size_t len) {
  uint8_t repeat = len >> 1;
  if (send_repeat_header(addr, UPDI_ST|UPDI_DATA2, repeat)) {
    do {
      if (!SEND(*data++)) break;
      if (UPDI_ACK != RECV()) break;
      if (!SEND(*data++)) break;
      if (UPDI_ACK != RECV()) break;
    } while (--repeat);
  }
  return len == 0;
}

bool UPDI::sts8rsd (uint32_t addr, uint8_t *data, uint8_t len) {
  _CAPS32(_set_ptr_l[2])->dword = addr;
  _set_repeat[2] = len - 1;
  _set_repeat[4] = UPDI_PTR_INC|UPDI_ST|UPDI_DATA1;
  if (!send_bytes(_set_ptr_l, sizeof(_set_ptr_l) - 1)) return false;
  if (UPDI_ACK != RECV()) return false;
  if (!set_cs_ctra(UPDI_GTVAL_RSD)) return false;
  if (!send_bytes(_set_repeat, sizeof(_set_repeat))) return false;
  do {              /* Repeat byte send */
    SEND(*data++);  /* Submission errors must be ignored */
  } while (--len);
  if (!set_cs_ctra(UPDI_GTVAL)) return false;
  return true;
}

bool UPDI::sts16rsd (uint32_t addr, uint8_t *data, size_t len) {
  _CAPS32(_set_ptr_l[2])->dword = addr;
  uint8_t repeat = len >> 1;
  _set_repeat[2] = repeat - 1;
  _set_repeat[4] = UPDI_PTR_INC|UPDI_ST|UPDI_DATA2;
  if (!send_bytes(_set_ptr_l, sizeof(_set_ptr_l) - 1)) return false;
  if (UPDI_ACK != RECV()) return false;
  if (!set_cs_ctra(UPDI_GTVAL_RSD)) return false;
  if (!send_bytes(_set_repeat, sizeof(_set_repeat))) return false;
  do {              /* Repeat word send */
    SEND(*data++);  /* Submission errors must be ignored */
    SEND(*data++);  /* Submission errors must be ignored */
  } while (--repeat);
  if (!set_cs_ctra(UPDI_GTVAL)) return false;
  return true;
}

/*
 * Reception
 */

uint8_t UPDI::ld8 (uint32_t addr) {
  static uint8_t set_ptr[] = {
      UPDI_SYNCH
    , UPDI_LDS|UPDI_ADDR3|UPDI_DATA1
    , 0, 0, 0, 0  // 24bit address
  };
  _CAPS16(set_ptr[2])->word = (uint16_t)addr;
  while (!send_bytes(set_ptr, sizeof(set_ptr) - 1)) BREAK();
  return RECV();
}

bool UPDI::lds8 (uint32_t addr, uint8_t *data, uint8_t len) {
  if (!send_repeat_header(addr, UPDI_LD|UPDI_DATA1, len)) return false;
  do { *data++ = RECV(); } while (--len);
  return UPDI_LASTH == 0;
}

bool UPDI::lds16 (uint32_t addr, uint8_t *data, size_t len) {
  uint8_t repeat = (uint16_t)len >> 1;
  if (!send_repeat_header(addr, UPDI_LD|UPDI_DATA2, repeat)) return false;
  do {
    *data++ = RECV();
    *data++ = RECV();
  } while (--repeat);
  return UPDI_LASTH == 0;
}

/*
 * Control status reception
 */

uint8_t UPDI::get_cs_stat (uint8_t code) {
  static uint8_t set_ptr[] = { UPDI_SYNCH, 0 };
  set_ptr[1] = UPDI_LDCS | code;
  send_bytes(set_ptr, sizeof(set_ptr));
  return RECV();
}

bool UPDI::is_cs_stat (uint8_t code, uint8_t check) {
  return check == (get_cs_stat(code) & check);
}

bool UPDI::is_sys_stat (uint8_t check) {
  return is_cs_stat(UPDI_CS_ASI_SYS_STATUS, check);
}

bool UPDI::is_key_stat (uint8_t check) {
  return is_cs_stat(UPDI_CS_ASI_KEY_STATUS, check);
}

/*
 * Control status transmission
 */

bool UPDI::set_cs_stat (uint8_t code, uint8_t data) {
  static uint8_t set_ptr[] = { UPDI_SYNCH, 0, 0 };
  set_ptr[1] = UPDI_STCS | code;
  set_ptr[2] = data;
  return send_bytes(set_ptr, sizeof(set_ptr));
}

bool UPDI::set_cs_ctra (uint8_t data) {
  return set_cs_stat(UPDI_CS_CTRLA, data);
}

bool UPDI::set_cs_ctrb (uint8_t data) {
  return set_cs_stat(UPDI_CS_CTRLB, data);
}

bool UPDI::set_cs_asi_ctra (uint8_t data) {
  return set_cs_stat(UPDI_CS_ASI_CTRLA, data);
}

uint8_t UPDI::get_cs_asi_ctra (void) {
  return get_cs_stat(UPDI_CS_ASI_CTRLA);
}

/* __attribute__((optimize("O0"))) */
bool UPDI::loop_until_sys_stat_is_clear (uint8_t bitmap, uint16_t limit) {
  #ifdef ENABLE_DEBUG_UPDI_SENDER
  uint16_t _back = _send_ptr;
  #endif
  do {
    if (!is_sys_stat(bitmap)) return true;
    #ifdef ENABLE_DEBUG_UPDI_SENDER
    _send_ptr = _back;
    #endif
    TIM::delay_50us();
  } while (--limit);
  return false;
}

/* __attribute__((optimize("O0"))) */
bool UPDI::loop_until_sys_stat_is_set (uint8_t bitmap, uint16_t limit) {
  #ifdef ENABLE_DEBUG_UPDI_SENDER
  uint16_t _back = _send_ptr;
  #endif
  do {
    if (is_sys_stat(bitmap)) return true;
    #ifdef ENABLE_DEBUG_UPDI_SENDER
    _send_ptr = _back;
    #endif
    TIM::delay_50us();
  } while (--limit);
  return false;
}

/* __attribute__((optimize("O0"))) */
bool UPDI::loop_until_key_stat_is_clear (uint8_t bitmap, uint16_t limit) {
  #ifdef ENABLE_DEBUG_UPDI_SENDER
  uint16_t _back = _send_ptr;
  #endif
  do {
    if (!is_key_stat(bitmap)) return true;
    #ifdef ENABLE_DEBUG_UPDI_SENDER
    _send_ptr = _back;
    #endif
    TIM::delay_50us();
  } while (--limit);
  return false;
}

/* __attribute__((optimize("O0"))) */
bool UPDI::loop_until_key_stat_is_set (uint8_t bitmap, uint16_t limit) {
  #ifdef ENABLE_DEBUG_UPDI_SENDER
  uint16_t _back = _send_ptr;
  #endif
  do {
    if (is_key_stat(bitmap)) return true;
    #ifdef ENABLE_DEBUG_UPDI_SENDER
    _send_ptr = _back;
    #endif
    TIM::delay_50us();
  } while (--limit);
  return false;
}

/* __attribute__((optimize("O0"))) */
bool UPDI::set_nvmprog_key (void) {
  if (!send_bytes(nvmprog_key, sizeof(nvmprog_key))) return false;
  return loop_until_key_stat_is_set(UPDI_KEY_NVMPROG);
}

/* __attribute__((optimize("O0"))) */
bool UPDI::set_erase_key (void) {
  if (!send_bytes(erase_key, sizeof(erase_key))) return false;
  return loop_until_key_stat_is_set(UPDI_KEY_CHIPERASE);
}

/* __attribute__((optimize("O0"))) */
bool UPDI::set_urowwrite_key (void) {
  if (!send_bytes(urowwrite_key, sizeof(urowwrite_key))) return false;
  return loop_until_key_stat_is_set(UPDI_KEY_UROWWRITE);
}

bool UPDI::read_sib (uint8_t *s_ptr) {
  static uint8_t set_ptr[] = { UPDI_SYNCH, UPDI_SIB_256 };
  uint8_t _len = 32;
  if (!send_bytes(set_ptr, sizeof(set_ptr))) return false;
  do { *s_ptr++ = RECV(); } while (--_len);
  return true;
}

/************************
 * HV pulse application *
 ************************/

void UPDI::HV_Pulse (void) {
  #ifdef ENABLE_DEBUG_UPDI_SENDER
  UPDI::_send_buf_push(JTAG2::updi_desc.hvupdi_variant);
  #endif
  if (JTAG2::updi_desc.hvupdi_variant != '0'
   && JTAG2::updi_desc.hvupdi_variant != '2') return;

  /* Run high voltage generator */
  TIM::HV_Pulse_ON();

  /* Perform a hardware reset (if wired) */
  openDrainWrite(TRST_PIN, LOW);
  TIM::delay_50us();
  openDrainWrite(TRST_PIN, HIGH);
  TIM::delay_800us();
  /* During this time, raise the circuit to sufficient voltage */

  if (JTAG2::updi_desc.hvupdi_variant == '0')
    digitalWrite(HV12_PIN, HIGH);
  else
    digitalWrite(HV8_PIN, HIGH);

  /* Apply high voltage only for the required time */
  TIM::delay_800us();

  if (JTAG2::updi_desc.hvupdi_variant == '0')
    digitalWrite(HV12_PIN, LOW);
  else
    digitalWrite(HV8_PIN, LOW);

  TIM::HV_Pulse_OFF();

  /* Keep the UPDI signal low for as long as necessary */
  // UPDI_USART.BAUD = UPDI_BAUD_SHORT_BREAK;
  UPDI_USART.BAUD = UPDI_BAUD_BREAK;
  SEND(UPDI_NOP);
  UPDI_USART.BAUD = UPDI_BAUD_CALC;

  bit_clear(UPDI_CONTROL, UPDI_CLKU_bp);
  bit_set(UPDI_CONTROL, UPDI_ERHV_bp);
}

/*****************************************
 * USERROW region writing *
 *****************************************/

bool UPDI::write_userrow (const uint32_t start_addr, uint8_t *data, const size_t byte_count) {
  /* If UPDI is not accessible, the operation cannot continue. */
  if (bit_is_clear(UPDI_CONTROL, UPDI::UPDI_INFO_bp)) return false;

  /* Only data lengths that are multiples of 32 bytes are allowed. */
  if (byte_count == 0 || byte_count & 0x1F) {
    JTAG2::packet.body[JTAG2::MESSAGE_ID] = JTAG2::RSP_ILLEGAL_MEMORY_RANGE;
    return true;
  }
  drain();
  if (!loop_until_sys_stat_is_clear(UPDI_SYS_RSTSYS, 500)) return false;

  /* Send the authentication key */
  if (!set_urowwrite_key()) return false;

  /* Transition to USERROW mode by system reset */
  if (!updi_reset(true) || !updi_reset(false)) return false;

  /* Wait for system reset to finish */
  if (!loop_until_sys_stat_is_clear(UPDI_SYS_RSTSYS, 500)) return false;

  /* Make sure you are in USERROW mode */
  loop_until_sys_stat_is_set(UPDI_SYS_UROWPROG);

  /* Write data to buffer memory */
  sts8rsd(start_addr, data, byte_count);
  /* Ignore any errors here */

  /* After writing the memory, write the end flag */
  set_cs_stat(UPDI_CS_ASI_SYS_CTRLA, UPDI_SET_UROWDONE | UPDI_SET_CLKREQ);

  /* Wait for data to be transferred to USERROW */
  /* AVR_Dx requires at least 100 * 50us wait loops */
  /* AVR_Ex may not end forever, so give up midway */
  loop_until_sys_stat_is_clear(UPDI_SYS_UROWPROG, 200);
  /* Ignore any errors here */

  /* Step completed */
  set_cs_stat(UPDI_CS_ASI_KEY_STATUS, UPDI_KEY_UROWWRITE);

  /* If previously in program mode, send unlock key */
  if (bit_is_set(UPDI_CONTROL, UPDI_PROG_bp)) {
    set_nvmprog_key();
  }

  /* Exit USERROW mode */
  if (!updi_reset(true) || !updi_reset(false)) return false;
  loop_until_sys_stat_is_clear(UPDI_SYS_RSTSYS);

  /* Make sure you are in program mode if necessary */
  if (bit_is_set(UPDI_CONTROL, UPDI_PROG_bp)) {
    loop_until_sys_stat_is_set(UPDI_SYS_NVMPROG);
  }
  return true;
}

/****************************
 * Delete all chips at once *
 ****************************/

/* This operation is valid when program mode is disabled. */
/* Otherwise you should use NVM::chip_erase().            */

// __attribute__((optimize("O0")))
bool UPDI::chip_erase (void) {
  /* If UPDI is prohibited, try HV control */
  if (bit_is_clear(UPDI_CONTROL, UPDI_INFO_bp)) {
    HV_Pulse();
  }
  drain();
  if (!loop_until_sys_stat_is_clear(UPDI_SYS_RSTSYS, 500)) return false;

  /* Set the NVMPROG key. This is useful when CRCSCAN is activated. */
  if (get_cs_stat(UPDI_CS_ASI_CRC_STATUS) & UPDI_CRC_STATUS_gm) {
    /* Communication errors are not checked. */
    set_nvmprog_key();
  }

  /* Transition to CHIPERASE mode by system reset */
  if (!set_erase_key()) return false;

  /* Issue a system reset */
  if (!updi_reset(true) || !updi_reset(false)) return false;

  /* If RSTSYS is true, it is still not accessible */
  loop_until_sys_stat_is_clear(UPDI_SYS_RSTSYS);

  /* If LOCKSTATUS is clear, the chip is unlocked */
  loop_until_sys_stat_is_clear(UPDI_SYS_LOCKSTATUS);

  /* Make sure the CHER bit is cleared before next reset */
  loop_until_key_stat_is_clear(UPDI_KEY_CHIPERASE);

  /* Chip erasure was successful */
  bit_set(UPDI_CONTROL, UPDI_ERFM_bp);

  /* Once the HV control and device is successfully unlocked, */
  /* you should be able to enter program mode. */
  if (!is_sys_stat(UPDI_SYS_NVMPROG)) {
    if (!set_nvmprog_key()) return false;
    if (!updi_reset(true) || !updi_reset(false)) return false;
    loop_until_sys_stat_is_clear(UPDI_SYS_LOCKSTATUS);
    loop_until_sys_stat_is_set(UPDI_SYS_NVMPROG);
  }

  /* After performing HV control, it is necessary to obtain SIB */
  bit_clear(UPDI_CONTROL, UPDI_INFO_bp);
  bit_set(UPDI_CONTROL, UPDI_PROG_bp);
  return enter_updi(true);
}

/**********************
 * UPDI control start *
 **********************/

bool UPDI::enter_updi (bool skip) {
  #ifdef ENABLE_UPDI_DOUBLESPEED
  const bool hv_val = SYS::get_vcc() >= 4250;
  #endif
  /* Release the physical reset */
  openDrainWrite(TRST_PIN, HIGH);
  /* target reset deactive */
  if (!skip) {
    /* HV control forced permission */
    if (bit_is_set(UPDI_CONTROL, UPDI_FCHV_bp)) {
      HV_Pulse();
      if (!loop_until_sys_stat_is_clear(UPDI_SYS_RSTSYS, 500)) return false;
      if (!set_cs_ctrb(UPDI_SET_CCDETDIS)) return false;

      /* send nvmprog_key */
      if (!set_nvmprog_key()) return false;

      /* restart target : change mode */
      if (!updi_reset(true) || !updi_reset(false)) return false;
      if (!loop_until_sys_stat_is_clear(UPDI_SYS_RSTSYS, 500)) return false;
    }
    else
      BREAK();
  }
  if (bit_is_clear(UPDI_CONTROL, UPDI_INFO_bp)) {
    /* Minimize guard time */
    if (!set_cs_ctrb(UPDI_SET_CCDETDIS)) return false;
    if (!set_cs_ctra(UPDI_GTVAL)) return false;
    _CAPS32(JTAG2::updi_desc.signature[0])->dword = -1;

    #ifdef ENABLE_UPDI_DOUBLESPEED
    if (hv_val && !set_cs_asi_ctra(UPDI_SET_UPDICLKSEL_8M)) return false;
    #endif

    if (is_sys_stat(UPDI_SYS_RSTSYS)) {
      updi_reset(false);
      if (!loop_until_sys_stat_is_clear(UPDI_SYS_RSTSYS, 500)) return false;
    }

    /*** Get System Information Block ***/
    /* Determine system requirements not announced by host control here */
    uint8_t* _p = &JTAG2::updi_desc.sib[0];
    if (!read_sib(_p)) return false;
    JTAG2::updi_desc.nvmctrl_version = _p[10];
    JTAG2::updi_desc.signature[0] = 0x1e;
    JTAG2::updi_desc.signature[1] = _p[0];
    JTAG2::updi_desc.signature[2] = _p[10];
    switch (_p[0]) {
      case 'm' : {              // 'megaAVR' series
        /* megaAVR SIB = 'megaAVR P:0D:1-3' */
        /* always vesrion 0 */
        bit_set(UPDI_NVMCTRL, UPDI_LOWF_bp);
        break;
      }
      case 't' : {              // 'tinyAVR' series
        /* tinyAVR SIB = 'tinyAVR P:0D:1-3' */
        /* always vesrion 0 */
        break;
      }
      case ' ' :                // 'AVR_DA' Regacy
        JTAG2::updi_desc.signature[1] = 'A';
      case 'A' : {              // 'AVR_Dx/Ex' series
        /* AVR Dx SIB = 'AVR     P:2D:1-3' */
        /* AVR DA SIB = '    AVR P:2D:1-3' (Regacy) */
        /* AVR EA SIB = 'AVR     P:3D:1-3' */
        /* AVR DU SIB = 'AVR     P:4D:1-3' */
        /* AVR EB SIB = 'AVR     P:5D:1-3' */
        if (JTAG2::updi_desc.nvmctrl_version == '3') {
          // 'AVR_Ex' series
          bit_set(UPDI_NVMCTRL, UPDI_GEN3_bp);
        }
        else if (JTAG2::updi_desc.nvmctrl_version == '4') {
          // 'AVR_DU' series
          bit_set(UPDI_NVMCTRL, UPDI_GEN4_bp);
        }
        else if (JTAG2::updi_desc.nvmctrl_version == '5') {
          // 'AVR_EB' series
          bit_set(UPDI_NVMCTRL, UPDI_GEN5_bp);
          bit_set(UPDI_NVMCTRL, UPDI_GEN3_bp);
        }
        bit_set(UPDI_NVMCTRL, UPDI_GEN2_bp);
        break;
      }
      default : {
        return false;
      }
    }
    bit_set(UPDI_CONTROL, UPDI_INFO_bp);
  }
  #ifdef ENABLE_UPDI_DOUBLESPEED
  if ((get_cs_asi_ctra() & UPDI_SET_UPDICLKSEL_bm) == UPDI_SET_UPDICLKSEL_8M) {
    volatile uint8_t tval = UPDI_LASTL;
    UPDI_USART.CTRLB = UPDI_USART_OFF;
    UPDI_USART.CTRLB = UPDI_USART_ON | USART_RXMODE_CLK2X_gc;
    bit_set(UPDI_CONTROL, UPDI_CLKU_bp);
    do { TIM::delay_50us(); } while (tval != get_cs_asi_ctra());
  }
  #endif
  return true;
}

/******************************
 * Programming control starts *
 ******************************/

bool UPDI::enter_prog (void) {
  if (bit_is_clear(UPDI_CONTROL, UPDI_PROG_bp)) {
    if (!loop_until_sys_stat_is_clear(UPDI_SYS_RSTSYS, 500)) return false;
    if (!is_sys_stat(UPDI_SYS_NVMPROG)) {
      if (!set_nvmprog_key()) return false;
      if (!updi_reset(true) || !updi_reset(false)) return false;
      if (!loop_until_sys_stat_is_clear(UPDI_SYS_RSTSYS, 500)) return false;
      loop_until_sys_stat_is_set(UPDI_SYS_NVMPROG);
    }
    bit_set(UPDI_CONTROL, UPDI_INFO_bp);
    bit_set(UPDI_CONTROL, UPDI_PROG_bp);
  }
  return true;
}

/**********************
 * UPDI authorization *
 **********************/

bool UPDI::updi_activate (bool hv_active) {
  volatile uint8_t count = 4;
  while (--count && bit_is_clear(UPDI_CONTROL, UPDI_PROG_bp)) {
    /* For the second lap, forced HV control is enabled by the CMND_RESET parameter */
    /* For the third lap, forced HV control of JP short is allowed. */
    if ((count == 2 && hv_active)
     || (count == 1 && JTAG2::updi_desc.hvupdi_variant != '1' 
                    && !digitalRead(JP_SENSE_PIN))) {
      bit_set(UPDI_CONTROL, UPDI_FCHV_bp);
    }
    if (setjmp(TIM::CONTEXT) == 0) {
      TIM::Timeout_Start(125);
      enter_updi(false) && enter_prog();
    }
    TIM::Timeout_Stop();
  }
  return bit_is_set(UPDI_CONTROL, UPDI_PROG_bp);
}

/************************
 * UPDI control process *
 ************************/

bool UPDI::runtime (uint8_t updi_cmd) {
  volatile bool _result = false;
  if (setjmp(TIM::CONTEXT) == 0) {
    TIM::Timeout_Start(800);
    switch (updi_cmd) {
      case UPDI_CMD_READ_MEMORY : {
        size_t byte_count = _CAPS16(JTAG2::packet.body[JTAG2::DATA_LENGTH])->word;
        uint32_t start_addr = _CAPS32(JTAG2::packet.body[JTAG2::DATA_ADDRESS])->dword;
        _result = NVM::read_memory(start_addr, byte_count);
        break;
      }
      case UPDI_CMD_WRITE_MEMORY : {
        _result = NVM::write_memory();
        break;
      }
      case UPDI_CMD_ERASE : {
        if (JTAG2::packet.body[JTAG2::MEM_TYPE] == JTAG2::XMEGA_ERASE_CHIP) {
          #ifdef ENABLE_ALWAYS_CHIPERASE_ASI
          _result = UPDI::chip_erase();
          #else
          _result = bit_is_set(UPDI_CONTROL, UPDI_PROG_bp) ? NVM::chip_erase() : UPDI::chip_erase();
          #endif
        }
        else {
          /* AVRDUDE>=8.0 should not return an error on page erase. */
          _result = true;
        }
        break;
      }
      case UPDI_CMD_GO : {
        _result = Target_Reset(true) && Target_Reset(false);
        break;
      }
    }
  }
  TIM::Timeout_Stop();
  UPDI_USART.CTRLB = UPDI_USART_ON;
  wdt_reset();
  if (!_result) drain();
  return _result;
}

// end of code
